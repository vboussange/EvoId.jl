var documenterSearchIndex = {"docs":
[{"location":"mathematics/pde.html#PDE-Equivalence","page":"PDE Equivalence","title":"PDE Equivalence","text":"","category":"section"},{"location":"mathematics/pde.html#Equivalence-with-PDE-models","page":"PDE Equivalence","title":"Equivalence with PDE models","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"HDR Champagnat Theorem 2.5 Section 2.2","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Recall that the IBM is a Markov process in mathcalM^1 which state at time t is the measure","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"    nu_t = sum_i=1^N_t delta_x_i","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Hence an individual with trait x in population nu_t gives birth to a new individual at rate b(x) and dies at rate","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"    d(x) + int c(xy)(nu_t(dy) - delta_x(dy)) = d(x) - c(xx) + sum_i=1^N_t c(cx_i)","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"The Dirac mass in the integral stands for the fact that an individual is not in competition with itself. Hence when N_t = 1 the competition term cancels. When there is birth,  with probability p(x) the offspring has trait y = x + H where H is a random variablee with law m(xh)dh.","category":"page"},{"location":"mathematics/pde.html#Assumptions","page":"PDE Equivalence","title":"Assumptions","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Assume that","category":"page"},{"location":"mathematics/pde.html#Assumption-1-:-bounds-and-parameters-regularity.","page":"PDE Equivalence","title":"Assumption 1 : bounds and parameters regularity.","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Functions bcdp are continuous and bounded, with positive are nul values\nexists barm forall x in D h in R^d m(xh) leq barm(h)","category":"page"},{"location":"mathematics/pde.html#Assumption-2","page":"PDE Equivalence","title":"Assumption 2","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"nu_t^K = frac1Knu_t where nu_t is constructed such that cequiv frac1Kc","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":" ","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Then we get the large population limit without mutation scaling","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"    partial_t u(tx) = u(tx) left((1-p(x))b(x) -d(x) int_D c(xy) u(ty) dyright) + int_D b(x)  p(y)  u(ty)  m(yx-y)dy","category":"page"},{"location":"mathematics/pde.html#Mutations","page":"PDE Equivalence","title":"Mutations","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Assuming a small mutational variance max sigma^2_i  1 and a mutation rate U, the mutational effects can be approximated by an elliptic operator sum_i=1^n (mu_i^2x)partial_ii with mu_i = sigma_isqrtU","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":":warning: check that with Burger","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"In other words (from Champagnat, Ferriere and Meleard 2006), we have","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"partial_t u(tx) =  u(tx)big(b(tx) - d(xu(tx)) big) + frac12 Delta (sigma^2 r mu u)(tx)","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"where ","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"d(xu(tx)) = (u ast c)(x)","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"and c is the competition function. For us, x in","category":"page"},{"location":"manual/agent.html#Agent-properties","page":"Agent properties","title":"Agent properties","text":"","category":"section"},{"location":"manual/agent.html#The-Agent-structure","page":"Agent properties","title":"The Agent structure","text":"","category":"section"},{"location":"manual/agent.html","page":"Agent properties","title":"Agent properties","text":"The atomic structure is the Agent. It has four attributes","category":"page"},{"location":"manual/agent.html","page":"Agent properties","title":"Agent properties","text":"the ancestors' history of traits, and the corresponding time where the traits have changed,\na death rate and a birth rate.","category":"page"},{"location":"manual/agent.html","page":"Agent properties","title":"Agent properties","text":"mutable struct Agent{A<:Ancestors,R<:Rates,T<:Tuple,U,V} <: AbstractAgent{A,R}\n    # history of traits for geotraits\n    x_history::Array{T,1}\n    # birth time of ancestors\n    t_history::Array{U,1}\n    # death rate\n    d::V\n    #birth rate\n    b::V\nend","category":"page"},{"location":"manual/agent.html","page":"Agent properties","title":"Agent properties","text":"!!! note Specificities     The type Agent has two important composite types","category":"page"},{"location":"manual/agent.html","page":"Agent properties","title":"Agent properties","text":"- `Ancestors{bool}` : when `bool = true`, the ancestors traits are stored,\n- `Rates{bool}` : when `bool = true`, the rates `d` and `b` of agents are updated at each time step. This is need in e.g. Gillepsie Algorithm","category":"page"},{"location":"manual/agent.html#","page":"Agent properties","title":"","text":"","category":"section"},{"location":"manual/agent.html","page":"Agent properties","title":"Agent properties","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_Agent.jl\"]","category":"page"},{"location":"manual/agent.html#ABMEv.Agent","page":"Agent properties","title":"ABMEv.Agent","text":"mutable struct Agent{A<:ABMEv.Ancestors, R<:ABMEv.Rates, T<:Tuple, U, V} <: AbstractAgent{A<:ABMEv.Ancestors,R<:ABMEv.Rates}\n\n\n\n\n\n","category":"type"},{"location":"manual/agent.html#ABMEv.Agent-Union{Tuple{S}, Tuple{P}, Tuple{S,P}} where S<:Tuple{Vararg{ABMEv.AbstractSpace,N} where N} where P<:Tuple","page":"Agent properties","title":"ABMEv.Agent","text":"Agent(s; ancestors, rates)\nAgent(s, pos; ancestors, rates)\n\n\nInitialises agent with `pos` provided\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#ABMEv.Agent-Union{Tuple{S}, Tuple{S}} where S<:Tuple{Vararg{ABMEv.AbstractSpace,N} where N}","page":"Agent properties","title":"ABMEv.Agent","text":"Agent(s; ancestors, rates)\n\n\nInitialises agent with 0 values everywhere\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#ABMEv.get_geo-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{R}, Tuple{A}, Tuple{Agent{A,R,T,U,V},Number}} where V where U where T where R where A<:ABMEv.Ancestors{true}","page":"Agent properties","title":"ABMEv.get_geo","text":"get_geo(a, t)\n\n\nReturns geotrait of agent a at time t\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#ABMEv.get_t-Tuple{Agent}","page":"Agent properties","title":"ABMEv.get_t","text":"get_t(a)\n\n\nGet time when agent born.\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#ABMEv.get_x-Tuple{AbstractAgent,Number,Integer}","page":"Agent properties","title":"ABMEv.get_x","text":"get_x(a, t, i)\n\n\nReturns trait i of the agent. Geotrait corresponds to dimension i=0.\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#ABMEv.increment_x!-Union{Tuple{T}, Tuple{R}, Tuple{A}, Tuple{AbstractAgent{A,R},Tuple{Vararg{ABMEv.AbstractSpace,N} where N},Dict,T}} where T where R where A<:ABMEv.Ancestors{true}","page":"Agent properties","title":"ABMEv.increment_x!","text":"increment_x!(a, s, p, t)\n\n\nThis function increments agent by random numbers specified in p ONLY FOR CONTINUOUS DOMAINS\n\n\n\n\n\n","category":"method"},{"location":"manual/simulation.html#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"manual/simulation.html","page":"Simulation","title":"Simulation","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_Sim.jl\"]","category":"page"},{"location":"manual/simulation.html#ABMEv.Simulation-Union{Tuple{World{A,S,T}}, Tuple{T}, Tuple{S}, Tuple{A}} where T where S where A","page":"Simulation","title":"ABMEv.Simulation","text":"\n\n\n\n","category":"method"},{"location":"manual/simulation.html#ABMEv.add_entry!-Union{Tuple{F}, Tuple{T}, Tuple{S}, Tuple{A}, Tuple{Simulation{A,S,T,F},World}} where F where T where S where A","page":"Simulation","title":"ABMEv.add_entry!","text":"add_entry!(s, w)\n\n\nAdd w with callbacks s.cb to s if provided\n\n\n\n\n\n","category":"method"},{"location":"mathematics/geotrait.html#The-geotrait","page":"The geotrait","title":"The geotrait","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"This note has been taken from 2Y/articles/geotrait/mathematical_notes.md","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"note: 'note' admonition\nIn Landscape Ecology, it is of particular interest to study the geographical position of the lineage through time. This is because richness patterns are thought to arise through allopatric speciation, where populations get separated in space and time. This is the topic of the following section.","category":"page"},{"location":"mathematics/geotrait.html#Julia-accessors","page":"The geotrait","title":"Julia accessors","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"An agents of type Agent{Ancestors{true}} stores the values of its ancestors traits. From it, one can thus study the history of the lineage.","category":"page"},{"location":"mathematics/geotrait.html#Projection-of-the-geographic-history","page":"The geotrait","title":"Projection of the geographic history","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Consider a set of individuals which lineage geographical history has been stored in a vector x^(i)(t). If individual i was born at time t^* then x^(i)(tt^*) represents its geographical position, while x^(i)(tt^*) represents its ancestors geographical position.","category":"page"},{"location":"mathematics/geotrait.html#Isolation-in-time","page":"The geotrait","title":"Isolation in time","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"We want to account for the isolation in time and possibly in space of the lineage of a given individual. That is, for how long and how distant stay lineages appart?","category":"page"},{"location":"mathematics/geotrait.html#Setting","page":"The geotrait","title":"Setting","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Consider a discrete setting, where N(t) individuals (or populations) evolve over a set of M demes disposed in a linear fashion, such that x^i(t) in 12M. The population is characterised by the counting measure","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"nu = sum_i^N(t) delta_x^i(t)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"We define the geographical history hamming distance mathfrakg as","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakhbig(x^(i)(t)x^(j)(t)big) = int_0^t textceil(fracx^(i) - x^(j)(s)M-1)ds","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"We extend this definition with the measure mathfrakh^* which takes into account geographic distance","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakh^*big(x^(i)(t)x^(j)(t)big) = int_0^t Bigx^(i) - x^(j) Big^2(s) ds","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Finally, we introduce the geotrait distance mathfrakg as","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakgbig(x^(i)(t)x^(j)(t)big) = Bigint_0^t (  x^(i) - x^(j) )(s)  dsBig^2","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Note that by the triangle inequality we have that","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakgbig(x^(i)(t)x^(j)(t)big) leq mathfrakh^*big(x^(i)(t)x^(j)(t)big)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Equality should arises if x^(i) x^(j) are positively linearly dependent (which should not be the case).","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"However, what we are eventually interested is a population measure. This measure should be related to the average pairwise distance across the population. Hence we define mathcalD_d(nut) such that","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathcalD_d(nut) = frac12N^2sum_i^N  sum_j^N d(x^(i)x^(j)t)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Let g^(i)(t) = int_0^t x^i(t) dt and G(t) = g^(i)(t) i in 12dotsN(t). By observing the following","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"frac12N^2sum_ij^N (y_i-y_j)^2 =\n frac12N^2sum_ij^N ((y_i-bary) -(y_j-bary))^2 \n = frac12N^2 2N sum_i^N(y_i-bary)^2 = textVar(Y)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Thus we have mathfrakgbig(x^(i)(t)x^(j)(t)big) = g^(i)(t) - g^(j)(t)^2  and hence","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    mathcalD_mathfrakg(nut) = textVar(G)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Also  remark that","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathcalD_h^*(nut) = frac12N^2sum_i^N  sum_j^N h^*(x^(i)x^(j)t) \n= frac12N^2sum_i^N  sum_j^N  int_0^t Bigx^(i) - x^(j) Big^2(s) ds \n= int_0^t  frac12N^2sum_i^N  sum_j^N  Bigx^(i) - x^(j) Big^2(s) ds \n= int_0^t textVar(X)(s)ds\n","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"One could also imagine a value h^(i)(t) = frac12Nsum_j^N(t)mathfrakh^*big(x^(i)(t)x^(j)(t)big) and in this case we would have","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    mathcalD_mathfrakh(nut) = frac1Nsum_i^N(t) h^(i)(t)","category":"page"},{"location":"mathematics/geotrait.html#Mobility","page":"The geotrait","title":"Mobility","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"How much do lineages move?","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Here is a time average of the speed","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    frac1N sum_i  partial_t x^(i)(t) _t \n    =  frac1N sum_i int_0^t partial_s x^(i)(s) ds \n    = frac1N sum_i x^(i)(t) - x^(i)(0))","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"But one could also have a moving average, that is, averaging","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    frac1N sum_i sum_j int_jtau^j(tau+1) frac1tau partial_s x^(i)(s) ds","category":"page"},{"location":"dev/notes.html#Developping-the-code","page":"Developping the code","title":"Developping the code","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"I recommend to first clone your branch in the directory you like best, and then to To develop, you ca","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"using Pkg\nPkg.dev(\"path_to_ABMEv_dir\")","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"You can also do the same trick with directly the gitlab address, cf Pkg.jl","category":"page"},{"location":"dev/notes.html#Future-directions","page":"Developping the code","title":"Future directions","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"Try to improve parallelism with the help of Threads.@Threads and @inbounds (cf tutorial )\nMake use of CUDA.jl to accelerate the simulations wih the use of GPU.","category":"page"},{"location":"dev/notes.html#Todo","page":"Developping the code","title":"Todo","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"abstract type AbstractAgent{A<:Ancestors,R<:Rates} end","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"It seems that we do not need to have the Rates{} parameter for Agent type.","category":"page"},{"location":"dev/notes.html#Notes","page":"Developping the code","title":"Notes","text":"","category":"section"},{"location":"dev/notes.html#Numerics","page":"Developping the code","title":"Numerics","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":":warning: Don’t pass expressions, or strings, pass functions","category":"page"},{"location":"dev/notes.html#Birth-and-Death-mechanisms","page":"Developping the code","title":"Birth and Death mechanisms","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"<!– > We are always balanced between taking the integral of the competition and resource kernel as constant, or taking its maximum peak as constant. –>","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"<!– :poop: –>","category":"page"},{"location":"dev/notes.html#Geotrait","page":"Developping the code","title":"Geotrait","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"The geotrait is calculated a posteriori, and is not taken into account during the simulation.","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"It used to be but for the sake of simplicity we now forget about it.","category":"page"},{"location":"examples/gillepsie.html#Gillepsie-simulation","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"","category":"section"},{"location":"examples/gillepsie.html#Diversification","page":"Gillepsie simulation","title":"Diversification","text":"","category":"section"},{"location":"examples/gillepsie.html#Gaussian-birth-coefficient,-Constant-carrying-capacity","page":"Gillepsie simulation","title":"Gaussian birth coefficient, Constant carrying capacity","text":"","category":"section"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0;\nsigma_K = .9;\nsigma_a = .7;\nK0 = 1000;\nK(X) = gaussian(X[1],0.,sigma_K)\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 2000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 10.0)\nna_init = K0\nworld0 = new_world_G(na_init,p_default,spread = .01)","category":"page"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: ABMEv_div_t4000)","category":"page"},{"location":"examples/gillepsie.html#Constant-birth-coefficient,-Gaussian-carrying-capacity","page":"Gillepsie simulation","title":"Constant birth coefficient, Gaussian carrying capacity","text":"","category":"section"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0;\nsigma_K = .9;\nsigma_a = .7;\nK0 = 1000;\nK(X) = 1\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0 / gaussian(X[1],0.,sigma_K)\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 4000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 20.0)\nna_init = K0","category":"page"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: ABMEv_bis_div.ong)","category":"page"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"what you could do would be to plot the adaptive dynamics of the monomorphic populations","category":"page"},{"location":"examples/gillepsie.html#Quadratic-birth-rate","page":"Gillepsie simulation","title":"Quadratic birth rate","text":"","category":"section"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0.125;\nsigma_a = 1.251;\nK0 = 1000;\nK(X) =  1 - a * X[1]^2\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 4000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 20.0)\nna_init = K0","category":"page"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: Unknown)","category":"page"},{"location":"examples/gillepsie.html#Equivalence","page":"Gillepsie simulation","title":"Equivalence","text":"","category":"section"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: PDE_quad_termsol) (Image: ABMEv_quad_time_average_distrib_deep_time)","category":"page"},{"location":"examples/gillepsie.html#No-diversification","page":"Gillepsie simulation","title":"No diversification","text":"","category":"section"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0;\nsigma_K = .9;\nsigma_a = 1.0;\nK0 = 1000;\nK(X) = gaussian(X[1],0.,sigma_K)\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 2000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 10.0)\nna_init = K0","category":"page"},{"location":"examples/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: Gillepsie_results_nodiversification)","category":"page"},{"location":"manual/plots.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"ABMEv comes with Plot recipes: plot(world::Array{U},p;what=[\"x\",\"H\"],trait = 1) where U <: Union{Missing,Agent{T}} where T.","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"An example to use it:","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"using Plots;pyplot()\nPlots.plot(worldall,p_default,what=[\"x\"],trait=2)","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"You can specify what you want to plot in the array what:","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"\"x\" returns a scatter plot (xaxis = time, yaxis = trait) . Geotrait corresponds to trait=0\n\"xs\" only works for agent type MixedAgent, because it needs a discrete geographical space. It returns a scatter plot (xaxis = geographical component, yaxis = trait value). Very similar to a histogram2d plot, with nicer look.\n\"gs\" returns a scatter plot (xaxis = geotrait, yaxis = trait value)\n\"3dgeo\" plots a 3d diagram with x axis as geotrait and y axis as the second component. :warning: this is probably weekend\n\"3d\" plots a 3d diagram with first and second component as x and y axis\n\"var\" plots the variance of the  component specified by trait=2 :question: with respect to time?\n\"vargeo\" plots the variance of the geotrait","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_plotting.jl\"]","category":"page"},{"location":"manual/world.html#World","page":"World","title":"World","text":"","category":"section"},{"location":"manual/world.html","page":"World","title":"World","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_world.jl\"]","category":"page"},{"location":"manual/world.html#ABMEv.get_geo-Tuple{World}","page":"World","title":"ABMEv.get_geo","text":"get_geo(w)\n\n\n\n\n\n\n","category":"method"},{"location":"manual/world.html#ABMEv.get_x-Tuple{World,Any}","page":"World","title":"ABMEv.get_x","text":"get_x(w, trait)\n\n\nReturns trait of every agents of world in the form of an array which dimensions corresponds to the input. If trait = 0 , we return the geotrait.\n\nWarning\n\nThis works only for linear subspace, indexed with a single value\n\n\n\n\n\n","category":"method"},{"location":"manual/world.html#ABMEv.get_xarray","page":"World","title":"ABMEv.get_xarray","text":"get_xarray(world)\nget_xarray(world, geotrait)\n\n\nReturns every traits of every agents of world in the form of a one dimensional array (in contrast to get_x). If geotrait=true the geotrait is also added to the set of trait, in the last column. If you do not want to specify t (only useful for geotrait), it is also possible to use get_xarray(world::Array{T,1}) where {T <: Agent}.\n\nWarning\n\nIt does not work with subspace where ndims(subspace) > 1.\n\n\n\n\n\n","category":"function"},{"location":"manual/world.html#Base.getindex-Tuple{World,Any}","page":"World","title":"Base.getindex","text":"getindex(w, i)\n\n\nGet x of world without geotrait.\n\n\n\n\n\n","category":"method"},{"location":"examples/comparison.html#Test","page":"Test","title":"Test","text":"","category":"section"},{"location":"examples/comparison.html#Gillepsie","page":"Test","title":"Gillepsie","text":"","category":"section"},{"location":"examples/comparison.html","page":"Test","title":"Test","text":"In Champagnat - HDR Memoire","category":"page"},{"location":"examples/comparison.html","page":"Test","title":"Test","text":"p = 0.1\nK = 1000\nsigm_mut = 0.01\nsigma_alpha = 0.7\nsigma_K = 0.9","category":"page"},{"location":"manual/gillepsie.html#Gillepsie-algorithm","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"","category":"section"},{"location":"manual/gillepsie.html#Mathematical-foundations","page":"Gillepsie algorithm","title":"Mathematical foundations","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"The original article by Gillepsie:","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"A general method for numerically simulating the stochastic time evolution of coupled chemical reactions","category":"page"},{"location":"manual/gillepsie.html#Rates","page":"Gillepsie algorithm","title":"Rates","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"Each individual is assigned a birth b_i and death d_i rate. The total rate is given by the sum of all individual rates","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"R(t) = left sum_i b_i(t) + d_i(t) right","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"A particular event, birth or death, is chosen at random with a probability equal to the rate of this event divided by the total rate R","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"This has to be checked, we are still not hundred percent sure","category":"page"},{"location":"manual/gillepsie.html#Time-steps","page":"Gillepsie algorithm","title":"Time steps","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"An event is exponentiallly distributed in time, with parameter lambda = U(t). This makes events memoryless, meaning that the probability of having a birth or death event is always the same, no matter when (P(X  s_t  X  t) = P(X  s).","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"Let B(t) = sum_i b_i(t) and  D(t) = sum_i d_i(t). Let T_b T_d the time for a birth or death event to occur. Then we have P(T_b  T_d) = fracB(t)B(t) + D(t)  (competing exponentials).","category":"page"},{"location":"manual/gillepsie.html#Inversion-method","page":"Gillepsie algorithm","title":"Inversion method","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"Let U be an mathcalU_(01)-distributed random variable and F colon R to 01 be a distribution function. Then we have","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"P(I_F(U) leq x ) = P(U leq F(x)) = F(x)","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"Thanks to the ***inversion method*** we get the incremental time step dt, exponentially distributed with parameter lambda = R(t), as","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"    dt(omega) = -fraclog(U(omega))R(t) iff X(omega) = exp(-U(t)dt(omega))","category":"page"},{"location":"manual/gillepsie.html#Initialize","page":"Gillepsie algorithm","title":"Initialize","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"new_world_G","category":"page"},{"location":"manual/gillepsie.html#Run","page":"Gillepsie algorithm","title":"Run","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"runWorld_store_G","category":"page"},{"location":"manual/gillepsie.html#Scenarios","page":"Gillepsie algorithm","title":"Scenarios","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"As of now, no mode is implemented. For further examples, check the folder examples in source code.","category":"page"},{"location":"manual/gillepsie.html#Specific-parameters","page":"Gillepsie algorithm","title":"Specific parameters","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"dt_saving = 10.","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"will allow to save the world every 10. time steps. If not specified, the algorithm will return first and last time step world.","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"NMax Maximum number of individuals that can be attained. If attained, then the programm stops.","category":"page"},{"location":"manual/gillepsie.html#Developping","page":"Gillepsie algorithm","title":"Developping","text":"","category":"section"},{"location":"manual/gillepsie.html#Efficiency","page":"Gillepsie algorithm","title":"Efficiency","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"The simulation are still very long. :flushed: How to improve it?","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"We think it would be more efficient if we found an other way of incrementing mutations","category":"page"},{"location":"manual/gillepsie.html#Parallelism","page":"Gillepsie algorithm","title":"Parallelism","text":"","category":"section"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"For now there is no parallelism implemented for one run","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"But we think we should rather set up a pmap or the macro @Threads to explore parameter space","category":"page"},{"location":"manual/gillepsie.html","page":"Gillepsie algorithm","title":"Gillepsie algorithm","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_Gillepsie.jl\"]","category":"page"},{"location":"manual/gillepsie.html#ABMEv.Gillepsie","page":"Gillepsie algorithm","title":"ABMEv.Gillepsie","text":"struct Gillepsie <: ABMEv.AbstractAlg\n\n\n\n\n\n","category":"type"},{"location":"manual/gillepsie.html#ABMEv.give_birth-Tuple{Int64,World}","page":"Gillepsie algorithm","title":"ABMEv.give_birth","text":"function give_birth(a::Agent,t,p::Dict)\n\nUsed for Gillepsie setting\n\n\n\n\n\n","category":"method"},{"location":"manual/gillepsie.html#ABMEv.updateWorld!-Union{Tuple{G}, Tuple{T}, Tuple{S}, Tuple{A}, Tuple{World{A,S,T},G}} where G<:Gillepsie where T where S where A","page":"Gillepsie algorithm","title":"ABMEv.updateWorld!","text":"function updateWorld_G!(world,t,p)\n\nUpdating rule for gillepsie setting. Returning dt drawn from an exponential distribution with parameter the total rates of events.\n\nArgs\n\nt is for now not used but might be used for dynamic landscape\n\n\n\n\n\n","category":"method"},{"location":"manual/gillepsie.html#ABMEv.update_rates!-Tuple{World,Gillepsie}","page":"Gillepsie algorithm","title":"ABMEv.update_rates!","text":"update_rates_std!(world,p::Dict,t::Float64)\n\nThis standard updates takes     - competition kernels of the form α(x,y) and     - carrying capacity of the form K(x)\n\n\n\n\n\n","category":"method"},{"location":"manual/run_world.html#Run-the-World","page":"Run the World","title":"Run the World","text":"","category":"section"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"For now three algorithms","category":"page"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"Gillepsie\nCFM\nWF","category":"page"},{"location":"manual/run_world.html#ABMEv.CFM","page":"Run the World","title":"ABMEv.CFM","text":"struct CFM <: ABMEv.AbstractAlg\n\n\n\n\n\n","category":"type"},{"location":"manual/run_world.html#ABMEv.WF","page":"Run the World","title":"ABMEv.WF","text":"struct WF <: ABMEv.AbstractAlg\n\n\n\n\n\n","category":"type"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"Warning : WF not implemented yet","category":"page"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_runworld.jl\"]","category":"page"},{"location":"manual/space.html#Space","page":"Space","title":"Space","text":"","category":"section"},{"location":"manual/space.html#Utils","page":"Space","title":"Utils","text":"","category":"section"},{"location":"manual/space.html","page":"Space","title":"Space","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_Space.jl\"]","category":"page"},{"location":"manual/space.html#ABMEv.AbstractSpace","page":"Space","title":"ABMEv.AbstractSpace","text":"abstract type AbstractSpace\n\nDim is the dimension of the space, T is the element type, I to indicate finiteness\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#ABMEv.ContinuousSegment","page":"Space","title":"ABMEv.ContinuousSegment","text":"struct ContinuousSegment{T<:AbstractFloat} <: ABMEv.AbstractSegment{T<:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#ABMEv.DiscreteSegment","page":"Space","title":"ABMEv.DiscreteSegment","text":"struct DiscreteSegment{T<:Integer} <: ABMEv.AbstractSegment{T<:Integer}\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#ABMEv.GraphSpace","page":"Space","title":"ABMEv.GraphSpace","text":"struct GraphSpace{T} <: ABMEv.AbstractSpace{1,T,ABMEv.IsFinite{true}}\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#ABMEv.RealSpace","page":"Space","title":"ABMEv.RealSpace","text":"struct RealSpace{N, T} <: ABMEv.AbstractSpace{N,T,ABMEv.IsFinite{false}}\n\nA real pace with dimension N and type T\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#ABMEv._reflect1D-Tuple{Number,Number,ABMEv.AbstractSegment}","page":"Space","title":"ABMEv._reflect1D","text":"_reflect1D(x, inc, s)\n\n\nHere we increment the trajectory of trait 1 such that it follows a reflected brownian motion (1D)\n\n\n\n\n\n","category":"method"},{"location":"manual/space.html#ABMEv.get_inc-Union{Tuple{I}, Tuple{T}, Tuple{Dim}, Tuple{Any,Any,ABMEv.AbstractSpace{Dim,T,I}}} where I<:ABMEv.IsFinite{false} where T where Dim","page":"Space","title":"ABMEv.get_inc","text":"get_inc(x, D, s)\n\n\nReturns increment corresponding to space s\n\n\n\n\n\n","category":"method"},{"location":"mathematics/mathematical_foundations.html#Mathematical-foundations","page":"Mathematical foundations","title":"Mathematical foundations","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Dieckmann and Law (probably more accessible than following), and then\nNicolas, Ferriere and Meleard","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"showed that the canonical equations of adaptive dynamics, describing the evolution in the phenotypic space, can be derived by considering the stochastic individual-based model corresponding to","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_t u(tx) = u(tx)(1-fracint alpha(xy) u(yt) dyK(x))\ntag1","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"in the limit of rare mutations, small mutational effects, and infinite population sizes.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Under these assumptions, Dieckmann and Law showed that adaptive dynamics is the first-order approximation of the mean path averaged over infinitely many realizations of the stochastic simulations obtained from the individual-based model.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"[[TOC]]","category":"page"},{"location":"mathematics/mathematical_foundations.html#The-basics-of-Adaptive-Dynamics","page":"Mathematical foundations","title":"The basics of Adaptive Dynamics","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This section is inspired from Adaptive Diversification, Doebeli 2011","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Imagine a monomorophic population with trait x, which follows the dynamics","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_t u(tx) = u(tx)bigb(x) - c(x)u(tx)big","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Logistic models are thought to be mathematically representative of a large class of models (During2008) :smirk:. Doebeli \"Chaos\" paper might also be relevant for this purpose","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Equilibrium is given by u^*(x) equiv K(x) = b(x)c(x). Hence one can reformulate equation above by","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    partial_t u(tx) = u(tx) left(b(x) - fracb(x)u(tx)K(x)right )","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Adaptive dynamics aims at determining the evolutionary trajectory of the trait x by considering the fate of rare mutants with traits y in resident monomorphic population with trait x. The resident population is assumed to be at equlibrium K(x). Because mutant is rare, the mutant's population dynamics is only affected by the density of the resident, which in turn is unaffected by the mutant's invasion attempt, and hence remains at K(x). Hence the effective density that mutant experiences during invasion attempt is detrmined by alpha(xy)K(x). The function  alpha is the competition kernel and describes the strength of competition that exerts the phenotype x on phenotype y.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"For our purpose, we consider it as symmetric, which corresponds to the canonical biological examples of birds with different beak size. We think this is also valid for plants, and in general along a genus.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"It is assumed that alpha(xx) = 1 (scaled to unity).","category":"page"},{"location":"mathematics/mathematical_foundations.html#Stabilising-selection","page":"Mathematical foundations","title":"Stabilising selection","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Stabilising selection ensures that trait x is contained, thus avoiding regions of extreme trait values that would be biologically unrealistic. It can appear by limiting birth rate b(x) or increasing death rate c(x) for extreme x","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Now we can determine the population dynamics of a mutant with population size N_mut and trait y experiencing the effective density N_eff = alpha(xy)K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"beginaligned\n    fracpartial N_mutpartial x(tx) = N_mut(b(y) - c(y)N_eff)\n    = N_mut(b(y) - c(y) alpha(xy)K(x))\n    = N_mut(b(y) - fracb(y) alpha(xy)K(x)K(y))\nendaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html#Invasion-fitness","page":"Mathematical foundations","title":"Invasion fitness","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The invasion fitness f(xy) corresponds to the fitness of a mutant with traits y in a resident monomorphic population with trait x","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"beginaligned\n    f(xy) = frac1N_mutfracpartial N_mutpartial t  = left( b(y) - c(y)N_eff right)\n    iff \n    f(xy) = b(y)left( 1 - fracalpha(xy)K(x)K(y) right)\nendaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":gun: Plot the fitness function in the case of the ABMEv","category":"page"},{"location":"mathematics/mathematical_foundations.html#Canonical-equation-for-the-Adaptive-Dynamics","page":"Mathematical foundations","title":"Canonical equation for the Adaptive Dynamics","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"fracd xd  t = m(x) D(x)  tag2","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"You should write it in the multidimensional case","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"D(x) = fracpartial f(xy)partial yBig_y=x is called the selection gradient\nm(x) is the mutational kernel. In Champagnat2011, it is denoted as m(x) = mu(x)  fracsigma_0^2(x)2  N(x) where mu denottes the probability that a birth from an individual with trait x gives rise to a mutation. sigma_0^2(x) denotes the variance of the distribution of a mutant trait y born from an individual with trait x. Even if the mutational effect is independent of x, the rate at which new mutations occur depends on the current population size N(x). If population is monomorphic, m only scales time. However, when population becomes polymorphic, mutation affects evolutionary dynamics.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":question:Essentially, adaptive dynamics is a first order approximation of the nonlinear dynamics of any evolutionary model","category":"page"},{"location":"mathematics/mathematical_foundations.html#Symmetric-competition-kernels","page":"Mathematical foundations","title":"Symmetric competition kernels","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Here we assume that b(x) = b in R and c(x) = bK(x). Thus the canonical equation for adaptive dynamics yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    fracd xd  t = bleft( alpha(xy)frac K (x)K(x) - partial_2 alpha(xy) right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Assuming that alpha(xy) = alpha(x-y) and maximum competition at 0, we have that partial_2 alpha(xx) = 0 and thus","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    fracd xd  t = b  alpha(xy)frac K (x)K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html#:heart:-Evolutionary-singularities:-D(x*)-\\partial_2-f(x*,x*)-0","page":"Mathematical foundations","title":":heart: Evolutionary singularities: D(x^*) = partial_2 f(x^*x^*) = 0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The fixed points of equation (2) are the points where the fitness gradient nullifies, and are called evolutionary singularities.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In this special case, the monomorphic population evolutionary dynamics is only driven by carrying capacity. Assuming a unimodal carrying capacity, the adaptive dynamics will always converge to the maximum of K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":question: This can be made explicit using the concept of singular points and convergence stability","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":rocket: unimodality of K(x) implies the existence of a unique singular point at the trait value maximising the carrying capacity","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"","category":"page"},{"location":"mathematics/mathematical_foundations.html#:heart:-Convergence-stability:-D'(x*)-0","page":"Mathematical foundations","title":":heart: Convergence stability: D(x^*)  0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Convergence stability of the singular point is determined by the quantity D(x^*)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Because x^* is a maximum, we have D(x^*) = bfracK(x)K(x)  0 hence the singular point is always convergence stable.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"By definition, selection vanishes at the singular point. Therefore, after convergence, second order effects of selection come at play, which is why the competition kernel and hence frequency dependence starts to be important.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In a d dimensional setting, convergence stability is obtained if the Jacobian matrix of the set of ODE (2) has all its eigenvalues negative at the singular point x^*.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":warning: in a multidimensional space, convergence stability nor being in the neihborhood of a singular point are required for evolutionary branching to occur.","category":"page"},{"location":"mathematics/mathematical_foundations.html#:heart:-Evolutionary-branching-point:-\\partial_{22}f(x*,x*)-0","page":"Mathematical foundations","title":":heart: Evolutionary branching point: partial_22f(x^*x^*)  0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In 1D, convergent stable singular point is either a maximum of minimum of the invasion fitness function. Note that for any y neq x^*, alpha(x^*y)alpha(x^*x^*) and K(y)K(x^*).","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":rocket: Whether x^* can be invaded by a mutant depends on the relative magnitude of these two effects, which in turns is determined by the curvature of the competition kernel and carrying capacity.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In our particular case we have","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_22f(x^*x^*) = b left(fracK(x^*) K(x) - alpha(x^*x^*) right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Hence we get that x^* is a fitness minimum, i.e. an evolutionary branching pointiff","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"alpha(x^*x^*)fracK(x^*) K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html#Reminder:","page":"Mathematical foundations","title":"Reminder:","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"(Image: Alt Text)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: in dimension D, the condition for minima is obtained by the determinant of the Hessian (The second partial derivative test)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Note that if  K(x) = exp(-frac(x-x_0)^22sigma_K^2) and alpha(xy) = exp(-frac(x-y)^22sigma_alpha^2)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"then above condition boils down to","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    sigma_alpha  sigma_K","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The Appendix of Doebeli2011 demonstrates from general dynamic systems theory that phenotypes x_1 and x_2 can coexist if they are close enough to the singular point.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Taylor-expansion-of-the-fitness-function","page":"Mathematical foundations","title":"Taylor expansion of the fitness function","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html#D","page":"Mathematical foundations","title":"1D","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Let's expand the fitness function for a scalar trait","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    f(xy) = f(xx) + partial_2 f(xx)(y-x) + partial_22 f(xx)frac(y-x)^22 + dots","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"First term is 0 for all x. The second term vanishes at the singular point, which is where the second order term come at play. If partial_22 f(x^*x^*) 0 no nearby mutants can invade the resident population that is monomorphic and thus conditions for evolutionary stability are obtained.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In contrast, partial_22f(x^*x^*)  0 is the condition for evolutionary instability, or potential evo- lutionary branching points, as the mutant now can potentially invade the resident.","category":"page"},{"location":"mathematics/mathematical_foundations.html#D-2","page":"Mathematical foundations","title":"2D","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    f(xy) = f(xx) + nabla_2 f(xx)(y-x) + frac12(y-x)^T nabla_2^2 f(xx) (y-x) + dots","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"We refer to nabla_2^2 f(xx) equiv H(x) as the hessian matrix.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In this scenario, the first-order term can become zero or be arbitrarily close to zero when the vector y-z is orthogonal or nearly orthogonal to the gradient nabla_2 f(xx). In other words, the second-order terms for trait values y that lie orthogonal to the direction of the gradient of f(x, y) become significant regardless of whether or not the trajectory is in the vicinity of a singular point. In particular, if H(x)is negative definite, no nearby mutants can invade the resident population that is monomorphic and we have the conditions for evolutionary stability.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: When the Hessian matrix has an eigenvector with a positive eigenvalue and this eigenvector has a nonzero projection in the subspace orthogonal to the direction of the selection gradient, we get the condition for evolutionary instability. The mutants from these directions can potentially invade the resident. Geometrically, the Hessian matrix at a particular point determines the local curvature of the level set of the function f(x y) as a function of y passing through that point. Depending on this curvature (the non- negativity of the Hessian matrix), there may exist directions along which the invasion fitness function has a minimum with respect to the mutant trait values and hence becomes evolutionary unstable.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Determining-the-dimorphic-steady-state:-D({\\bf-x})-D(x_1,x_2)-\\begin{pmatrix}D_1(x_1,x_2)-\\\\-D_2(x_1,x_2)\\end{pmatrix}-\\begin{pmatrix}\\partial_3f(x_1,x_2,x_1)\\\\\\partial_3f(x_1,x_2,x_2)-\\end{pmatrix}-{\\bf-0}","page":"Mathematical foundations","title":"Determining the dimorphic steady state: D(bf x) = D(x_1x_2) = beginpmatrixD_1(x_1x_2)  D_2(x_1x_2)endpmatrix = beginpmatrixpartial_3f(x_1x_2x_1)partial_3f(x_1x_2x_2) endpmatrix = bf 0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Consider mutants in the dimorphic population (x_1x_2). Ecological dynamics yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    beginaligned\n        partial_t N_1 = bN_1(1-fracN_1 + alpha(x_1x_2)N_2K(x_1)) \n        partial_t N_2 = bN_2(1-fracN_2 + alpha(x_1x_2)N_1K(x_2))\n    endaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Equilibrium densities are given by","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    beginaligned\n    N_1^* = N_2^* = fracexpleft(x_1^2left( frac2sigma_alpha^2 - frac12sigma_K^2 right)right)1+expleft(frac2x_1^2sigma_alpha^2right)\n    endaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Hence invasion fitness in the dimorphic population (x_1x_2) is","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    f(x_1x_2y) =bleft(1 - fracleft( alpha(x_1y)N_1^* + alpha(x_2y)N_2^*right)K(y)right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Thus the selection gradient in the resident x_1 yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    beginaligned\n    D_1(x_1x_2) = partial_3f(x_1x_2x_1)\n    = dots\n    endaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The 2-dimensional adaptive dynamics systems yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    fracd bf xdt = m(bf x)D(bf x)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"where the mapping m colon R^2 toR^2 decsribes the mutational process in the two resident strains.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"look Appendix Doebeli2011 that deals with mutations","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"With symmetric Gaussian competition we get","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    x_1^* = x_2^* = sqrtlnleft(frac2sigma_K^2sigma_alpha^2 - 1right)fracsigma_alpha^22","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":gun: This is a good way to check that your IBM is working!!!","category":"page"},{"location":"mathematics/mathematical_foundations.html#Convergence-stability-of-the-dimorphic-state:-J_D(x_1*,x_1*)","page":"Mathematical foundations","title":"Convergence stability of the dimorphic state: J_D(x_1^*x_1^*)","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"If the eigenvalues of the Jacobian matrix J_D(x_1^*x_1^*)are negative, then after after evolutionary branching the two phenotypic branches converge to x_1^* and x_2^*.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Evolutionary-branching-of-the-dimorphic-state","page":"Mathematical foundations","title":"Evolutionary branching of the dimorphic state","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":flushed: because of the symmetry assumption the two singular strategies either both represent local maxima or minima for the invasion fitnessfunction. It can be shown that whenever sigma_alphasigma_K both singular strategies are fitness minima, hence evolytionarily unstable.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Behaviour-in-deep-time","page":"Mathematical foundations","title":"Behaviour in deep time","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Evolutionary branching continues ad infinitum, that is when time goes to inifinity there is infinitely many branches with decreasing population starting from carrying capacity maximum. This is a peculariaty of the Gaussian kernel. Hence the popupulation will simply be polymorphic, normally distributed. This is what we observe from our PDE model.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: Doebeli2011 claims that Gaussian ecological functions in stochastic IBM for finite populations typically leads to only a small number of successive events","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: This is why it makes sense to extend this work to a continuous setting.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Quadratic-carrying-capacity","page":"Mathematical foundations","title":"Quadratic carrying capacity","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Competition kernel is still assumed gaussian. Now","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    K(x) = 1-ax^2","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Conditions for the singular point to be an evolutionary branching point yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    sigma_alpha  frac1sqrt2a","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Not possible to get explicit expression for the singular coalition of the two dimensional dynamics, but one can give examples and solve it numerically. The coexisting strategies are evolutionary stable as long as sigma_alpha is not too small. For example, take","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"a= 0.125","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Evolutionary stability is obtained for 125  sigma_alpha  2","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":flushed: also important to note that even if the coexisting points are not convergent stable the four dimensional adaptive dynamics can have a singular coalition in which all strains are evolutionary stable.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: This proves that even if frequency dependent is strong enough to induce diversification, it noes not necessarily lead to an infinite series of subsequent branching events.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":gun: We made the simulation for the corresponding PDE, and this is what we get (Image: Alt Text) Note that is proves to be a stiff problem when mu neq 0","category":"page"},{"location":"mathematics/mathematical_foundations.html#Derive-the-particular-case-for-Eq.-(1)","page":"Mathematical foundations","title":"Derive the particular case for Eq. (1)","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html#Particular-case-of-the-logistic-map","page":"Mathematical foundations","title":"Particular case of the logistic map","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"At equilibrium, the monomorphic resident population is distributed along the resource such that  u(tx) = K(x) since we consider that alpha(xx) = 1.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This is different for mutator selector equation, but you should check it\nAlso check it with varying birth rate, as Champagnat example","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Invasion fitness for the logistic map, of a rare mutant y is its per capital rate of growth in a resident population with phenotype x and is given by","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":" f(xy) = left(1-fracalpha(xy)K(x)K(y) right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Indeed","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This has to be checked","category":"page"},{"location":"mathematics/mathematical_foundations.html#Competition-and-resource-Kernel","page":"Mathematical foundations","title":"Competition and resource Kernel","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Evolutionary dynamics from deterministic microscopic ecological processes shows that adding a power to the kernels does not modify the adaptive dynamics evolutionary trajectories. It just accelerates its rates.\nThe shape of the competition and carrying capacity kernels affects the likelihood of disruptive selection presents alternative functional forms for competition and resource kernels, and investigate its impact on diversification. Box-like kernel can facilitate evolutionary branching.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Conditions-for-diversification","page":"Mathematical foundations","title":"Conditions for diversification","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Under the dynamics above, we have that adaptive diversification happen under the condition","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"fracpartial^2 f partial x^2(xy)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This is also tackled in Champagnat's memoire is Section 1.4.3, with example in Section 1.2.2.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Mutation","page":"Mathematical foundations","title":"Mutation","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Here we discuss how we can introduce mutation in Eq. (1) so that we obtain","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_t u(tx) = u(tx)(1-fracint alpha(xy) u(yt) dyK(x)) + Delta_x u(tx)\ntagmutations","category":"page"},{"location":"mathematics/mathematical_foundations.html#Correspondance-with-Individual-Based-Model","page":"Mathematical foundations","title":"Correspondance with Individual  Based Model","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The Canonical Equation of Adaptive Dynamics: A Mathematical View has derived for the first time canonical expression from first principles, based on taking limits of a jump process","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"inifinite population\nmutation are very rare, that is ecological and evolutionary timescales are separated.","category":"page"},{"location":"mathematics/mathematical_foundations.html#References","page":"Mathematical foundations","title":"References","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"A very good introduction in Adaptive Dynamics on Wikipedia (in French):","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Dynamique Adaptive ","category":"page"},{"location":"mathematics/minimal_abm.html#Minimal-individual-based-model","page":"Minimal individual based model","title":"Minimal individual based model","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"There are infinitely many invasion fitness functions with different competition kernels that give the same adaptive dynamics.","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Madhok2020 describes the minimal competition kernel","category":"page"},{"location":"mathematics/minimal_abm.html#Minimal-individual-based-model-2","page":"Minimal individual based model","title":"Minimal individual based model","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Described from Ispolatov et al. 2016 (cf references). Adaptive dynamics is written as","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"    dotx_i = ((nabla_y alpha)(xx))_i + ((nabla_x ln(K))(x))_i = w_i(x) + u_i(x)","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"It is assumed a standard carying capacity of the form","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"    K(x) = exp(-x^44)","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"The minimal competition kernel is defined as","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"alpha(xy) = expleft(sum_i w_i(x)(x_i-y_i) right)","category":"page"},{"location":"mathematics/minimal_abm.html#Gaussian-competition-kernel-and-adaptive-diversification","page":"Minimal individual based model","title":"Gaussian competition kernel and adaptive diversification","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Consider","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"alpha(xu) = expleft( sum_i w_i(x) (x_i-y_i)+frac(x_i-y_i)\n^22sigma_i^2right)","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Which has Hessian matrix","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"fracpartial^2 fpartial y_i partial y_j(xy) = -w_i(x)w_j(x) + w_j(x) x_i^3 - 2 x_i^3x_j^3 - left(3 x_i^2 - frac1sigma_i^2 right) delta_ij","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"This Hessian matrix can possess positive eigenvalues depending on the variance of the Gaussian components sigma_i and the coordinates in the phenotypic space.","category":"page"},{"location":"mathematics/minimal_abm.html#References","page":"Minimal individual based model","title":"References","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Evolutionary dynamics from deterministic microscopic ecological processes","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"This paper proposes a new deterministic way of running an IBM. The nice thing about it is that it is still compatible with the canonical equation of adaptive dynamics, and runs faster than other models.","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Individual-based models for adaptive diversification in high-dimensional phenotype spaces","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"This paper provides a method to construct individual-based models such that they faithfully reproduce the given adaptive dynamics attractor without diversification - cf the minimal competition kernel. It then shows that a propensity to diversify can be introduced by adding Gaussian competition terms that generate frequency dependence while still preserving the same adaptive dynamics. For sufficiently strong competition, the disruptive selection generated by frequency-dependence overcomes the directional evolution along the selection gradient and leads to diversification in phenotypic directions that are orthogonal to the selection gradient.","category":"page"},{"location":"manual/wright_fisher.html#Wright-Fisher-algorithm","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"","category":"section"},{"location":"manual/wright_fisher.html#Foundations","page":"Wright  Fisher algorithm","title":"Foundations","text":"","category":"section"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"The Wright Fisher process is an individual based model where the number of agents is constant through time. It is helpful to visualize it through marbles in jar:","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"(Image: alt text)","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"At each time step, N agents are picked up from previous generation to reproduce. Their number of offspring is proportional to their fitness, calculated as usual with birth and death rates.","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"It takes thus only one time step to go trough one generation. Thus it is more suit- able for numerical simulations. In practice, the Moran and Wright–Fisher models give qualitatively similar results, but genetic drift runs twice as fast in the Moran model.","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"From this perspective we can easily get that branches are less stable than in the Gillepsie scenario, for as as time goes to infinity the probability of going extinct is intuitively bigger than 0.","category":"page"},{"location":"manual/wright_fisher.html#Initial-conditions","page":"Wright  Fisher algorithm","title":"Initial conditions","text":"","category":"section"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"One need to construct the world as an array of agents, which will be the ancestors of the following","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"    agents = [Agent( [2e-1]  .* randn(1)) for i in 1:K0]","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"The function","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"is then called p[\"tend\"] -1 times.","category":"page"},{"location":"manual/wright_fisher.html#Scenarios","page":"Wright  Fisher algorithm","title":"Scenarios","text":"","category":"section"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"You have several options available concerning the resource implemented and competition:","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"mode=\"std\" is the standard mode\nmode=\"grad2D\" corresponds to a an ecological gradient","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"We are not sure whether this corresponds to the following two images","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"mode=\"mountain\" corresponds to a scenario where a mountain arises (with an ecological gradient)\nmode=\"split\" corresponds to a scenario where the resource is splitted in two\nmode=\"graph\" this guy is probably not working","category":"page"},{"location":"manual/wright_fisher.html#Parallelism","page":"Wright  Fisher algorithm","title":"Parallelism","text":"","category":"section"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"You can run your script in parallel, which makes sense for large populations. To do so:","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"using Distributed;addprocs()\n@everywhere using ABMEv","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"Parallelism only works with Wright Fisher model.","category":"page"},{"location":"manual/wright_fisher.html","page":"Wright  Fisher algorithm","title":"Wright  Fisher algorithm","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_WF.jl\"]","category":"page"},{"location":"manual/wright_fisher.html#ABMEv.updateWorld_WF!-NTuple{5,Any}","page":"Wright  Fisher algorithm","title":"ABMEv.updateWorld_WF!","text":"function updateWorld_WF!(world,newworld,C,p,update_rates!,t)\n    If p[\"reflected\"]=true, we reflect only first trait corresponding to geographic position\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#Diversity-measures","page":"Diversity measures","title":"Diversity measures","text":"","category":"section"},{"location":"manual/diversity.html","page":"Diversity measures","title":"Diversity measures","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_metrics.jl\"]","category":"page"},{"location":"manual/diversity.html#ABMEv.H_discrete-Tuple{Any}","page":"Diversity measures","title":"ABMEv.H_discrete","text":"H_discrete(s)\n\nInterconnectedness measure as in Nordbotten 2018 for discrete setup\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#ABMEv.covgeo","page":"Diversity measures","title":"ABMEv.covgeo","text":"covgeo(world::Array{Agent,1},trait = 0)\n\nIf trait = 0, returns the variance of the geotrait, knowing that by default it is associated with position trait 1. If trait > 0, returns the covariance matrix, with first row geotrait and second row trait\n\nNotes\n\nThis might be deprecated in the future\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#ABMEv.findclusters","page":"Diversity measures","title":"ABMEv.findclusters","text":"findclusters(v::Vector,allextrema =true)\n\nReturns a tuple with the cluster mean and its associated weight\n\nArguments\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#ABMEv.get_alpha_div","page":"Diversity measures","title":"ABMEv.get_alpha_div","text":"get_alpha_div(world::Array{U,1},t::Number,trait=1) where U <: Union{Missing,Agent}\n\nMean of the local variance of trait per patch. If trait=0, we get the mean of the local variance of the geotrait\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#ABMEv.get_beta_div","page":"Diversity measures","title":"ABMEv.get_beta_div","text":"get_beta_div(world::Array{U,1},t::Number,trait=1) where U <: Union{Missing,Agent}\n\nVariance of the mean of trait per patch\n\nArguments\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#ABMEv.get_dist_hist","page":"Diversity measures","title":"ABMEv.get_dist_hist","text":"function get_dist_hist(a1,a2,dist,trait=1,time = 0)\n\nReturns the integral of the distance dist through time of trait between a1.x and a2.x.\n\nint d(x_1x_2t)dt\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#ABMEv.get_local_pairwise_average_isolation-Tuple{World}","page":"Diversity measures","title":"ABMEv.get_local_pairwise_average_isolation","text":"function get_local_pairwise_average_isolation(world,dist,trait=1)\n\nSimilar to get_pairwise_average_isolation, but the pairwise distance is calculated within demes. An average of this metrics by deme is return.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#ABMEv.get_pairwise_average_isolation-Tuple{World}","page":"Diversity measures","title":"ABMEv.get_pairwise_average_isolation","text":"function get_pairwise_average_isolation(world;trait=1,trunc=false)\n\nReturns the integrated pairwise squared distance between all agents of world wrt trait. If trunc=true then the distance is truncated to binary value 0 or 1.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#ABMEv.hamming-Union{Tuple{World}, Tuple{T}} where T<:Int64","page":"Diversity measures","title":"ABMEv.hamming","text":"function hamming(world::Array{Agent,1})\n\nReturns a matrix H where Hij = hamming(ai,a_j). The hamming distance is taken through the whole history and functional space of the agents.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#Statistics.mean-Tuple{World}","page":"Diversity measures","title":"Statistics.mean","text":"function mean(world::World;trait=1)\n\nReturns the mean of the world's trait distribution. If trait = 0, returns the variance of the geotrait,\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#Statistics.var-Tuple{World}","page":"Diversity measures","title":"Statistics.var","text":"function var(world::World;trait=1)\n\nReturn the variance of the world's trait distribution. If trait = 0, returns the variance of the geotrait, knowing that by default it is associated with position trait 1.\n\nNotes\n\nFor now, the variance of a trait defined on a GraphSpace is calculated thanks to the Fiedler vector (cf https://mathworld.wolfram.com/FiedlerVector.html)\n\n\n\n\n\n","category":"method"},{"location":"index.html#ABMEv.jl-Documentation","page":"Home","title":"ABMEv.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This is a suite for simulating an Agent Based Model that captures the evolutionary dynamics of a population in a multidimensional space.","category":"page"},{"location":"index.html#How-it-works","page":"Home","title":"How it works","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This library helps you studying the evolution of a population of agents that evolve into some multidimensional space.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Define a space\nDefine birth and death function, that depend on agents traits, population state and time\nDefine mutation function\nInitialise the world and run the simulation according to some updating algorithm\nObtain a summary of the population state","category":"page"},{"location":"index.html#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using ABMEv","category":"page"},{"location":"index.html#Parameters-of-the-simulation","page":"Home","title":"Parameters of the simulation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Parameters are stored in the parameter dictionary p","category":"page"},{"location":"index.html#General-parameters","page":"Home","title":"General parameters","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"\"reflected\"=>true: if true then reflection occurs on the first trait -which should stand for geographic position. Depending on the agent type, reflections occurs in the domain -11 or between nodes 1 and p[\"nodes\"]\n\"alpha\" => α: is the competition function\n\"K\" => K: is the birth rate\n\"tend\" => 1.5: is the time to end simulation","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":":warning: Check how to define functions α and K in the algorithm section.","category":"page"},{"location":"index.html#Mutation","page":"Home","title":"Mutation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If anisotropy in mutation, the following parameters should be declared as arrays where each entry corresponds to a dimension.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"mu The probability of mutation.\nD If mutation happens on the agent, the increment follows mathcalN_ 0 D","category":"page"},{"location":"index.html#Birth","page":"Home","title":"Birth","text":"","category":"section"},{"location":"index.html#Growth","page":"Home","title":"Growth","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"K is the birth coefficient ( b(x) = K(x) )","category":"page"},{"location":"index.html#Death","page":"Home","title":"Death","text":"","category":"section"},{"location":"index.html#Competition","page":"Home","title":"Competition","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Competition between agent with trait x and y is defined as","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"α(x,y)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Death coefficient is defined as d(x^(i)) = sum_j^N(t) alpha(x^(i)x^(j))","category":"page"},{"location":"index.html#Fitness","page":"Home","title":"Fitness","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Fitness is defined internally as b - d.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TODO b here is confounded with K.","category":"page"},{"location":"index.html#Launching-simulation","page":"Home","title":"Launching simulation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Two type of simulation algorithm can be used","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"manual/gillepsie.md\",\n        \"manual/wright_fisher.md\"]\nDepth = 5","category":"page"},{"location":"index.html#Gillepsie-algorithm","page":"Home","title":"Gillepsie algorithm","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using ABMEv\n## Defining parameters\nsigma_K = 1.; #bandwith of resource\nsigma_a = 1.2; #bandwith of competition\nK0 = 1000 #carrying capacity\nK(X) = gaussian(X[1],0,Float32(sigma_K)) #birth\nalpha(X,Y) = gaussian(X[1],Y[1],Float32(sigma_a)) / Float32(K0) #competition\nD = [1e-2] #mutation range\nmu = [1.] #probability of mutation\nNMax = 2000 #number of individual\ndt_saving = 1.0 #time step saving\ntend = 1000.\nusing UnPack\np = Dict{String,Any}()\n@pack! p = K,alpha,D,mu,NMax,dt_saving,tend\n\n## Initial conditions\nagent0 = [Agent(.1 .* randn(Float32,1)) for i in 1:K0]\nworld0 = vcat(agent0[:],repeat([missing],Int(p[\"NMax\"] - K0)))\n\n## launch simulation\nworldall,p[\"tspan\"] = runWorld_store_G(p,world0);\n\nusing Plots\nPlots.plot(worldall,p)","category":"page"},{"location":"index.html#Wright-Fisher-algorithm","page":"Home","title":"Wright Fisher algorithm","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"sigma_K = .9;\nsigma_a = 1.251;\nK0 = 1000;\n# K(X) = gaussian(X[1],0.,sigma_K)\nK(X) = 1 - 0.125 * sum(X.^2)\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 10.)\nna_init = K0\nagents = [Agent( [1e-2]  .* randn(1) .- .5) for i in 1:K0]\n@time worldall_test,p[\"tspan\"] = runWorld_store_WF(p,agents,mode=\"std\");","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Champagnat and Ferriere founding article\nChampagnat and Ferriere second article - 2008","category":"page"},{"location":"index.html#Similar-packages:","page":"Home","title":"Similar packages:","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Agents.jl It would be worth to have a look! It has been designed by Ali R. Vahdati, from UZH.","category":"page"},{"location":"manual/utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"manual/utils.html","page":"Utils","title":"Utils","text":"Modules = [ABMEv]\nPages   = [\"ABMEv_utils.jl\"]","category":"page"},{"location":"manual/utils.html#ABMEv.DiversityFunction","page":"Utils","title":"ABMEv.DiversityFunction","text":"struct DiversityFunction\n\n\n\n\n\n","category":"type"},{"location":"manual/utils.html#ABMEv.arithsmooth-Tuple{Any,Any,Any}","page":"Utils","title":"ABMEv.arithsmooth","text":"function arithsmooth(x,y,smooth)\n\n-x is the shifted x-axis vector, due to smoothing -y is the smoothed value Returning a tuple\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.arithsmooth-Tuple{Any,Any}","page":"Utils","title":"ABMEv.arithsmooth","text":"function arithsmooth(x,smooth)\n\narithmetic smoothing\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.arithsmooth2D-NTuple{4,Any}","page":"Utils","title":"ABMEv.arithsmooth2D","text":"function arithsmooth2D(xa,ya,itp,smooth)\n\nReturn xas,yas,A where A is an interpolated matrix with arithmetic smooth, whose axis are xas, yas\n\nARGS\n\nxa xaxis values, ya yaxis values,  itp interpolation function, smooth smoothing function\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.gaussian-Tuple{Number,Number,Number}","page":"Utils","title":"ABMEv.gaussian","text":"    gaussian(x::Number,mu::Number,sigma::Number) = generalised_gaussian(x,mu,sigma,2)\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.generalised_gaussian-NTuple{4,Number}","page":"Utils","title":"ABMEv.generalised_gaussian","text":"    generalised_gaussian(x::Number,mu::Number,sigma::Number,epsilon::Number)\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.geomsmooth-Tuple{Any,Any,Any}","page":"Utils","title":"ABMEv.geomsmooth","text":"function geomsmooth(x,y,smooth)\n\n-x is the shifted x-axis vector, due to smoothing -y is the smoothed value Returning a tuple\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.geomsmooth-Tuple{Any,Any}","page":"Utils","title":"ABMEv.geomsmooth","text":"function geomsmooth(x,smooth)\n\nGeometric smoothing, cf https://en.wikipedia.org/wiki/Exponential_smoothing\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.geomsmooth2D-NTuple{4,Any}","page":"Utils","title":"ABMEv.geomsmooth2D","text":"function geomsmooth2D(xa,ya,itp,smooth)\n\nReturn xas,yas,A where A is an interpolated matrix with geometric smooth, whose axis are xas, yas\n\nARGS\n\nxa xaxis values, ya yaxis values,  itp interpolation function, smooth smoothing function\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.interpolate_df-NTuple{4,Any}","page":"Utils","title":"ABMEv.interpolate_df","text":"function interpolate_df(df,xlab,ylab,zlab)\n\nreturns an interpolated function itp(x,y) -> z, as well as its axis xa and ya\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#ABMEv.ma-Union{Tuple{T}, Tuple{Array{T,N} where N,Any}} where T<:Number","page":"Utils","title":"ABMEv.ma","text":"ma(x::Array{T},f) where T <: Number\n\nMoving average over array x, using f as the filter, i.e. the number of points to average on. Better choosing an odd number\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#DataFrames.groupby-Union{Tuple{T}, Tuple{Any,Array{T,N} where N}} where T","page":"Utils","title":"DataFrames.groupby","text":"function groupby(f, list::Array)\n\nreturns a dictionary that group list elements by value of function f\n\n\n\n\n\n","category":"method"}]
}
